(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{212:function(n,e,t){"use strict";t.r(e);var a=t(0),r=Object(a.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h3",{attrs:{id:"_1-数组的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组的解构赋值"}},[n._v("#")]),n._v(" 1.数组的解构赋值")]),n._v(" "),t("pre",[t("code",[n._v("从数组和对象中按照一定模式进行取值，对变量进行赋值，称为解构\n")])]),n._v(" "),t("p",[n._v("基本用法：")]),n._v(" "),t("pre",[t("code",[n._v("let [a,b,c] = [1,2,3];\n//a = 1;\n//b = 2;\n//c = 3;\n没有返回undefined;\nvar [,,a] = [1,2,3]\n//a = 3;\nvar [a,..b] = [1,2,3,4]\n//a = 1;\n//b = [2,3,4]\n")])]),n._v(" "),t("p",[n._v("默认值\n解构赋值允许指定默认值。")]),n._v(" "),t("pre",[t("code",[n._v("let [foo = true] = [];\nfoo // true\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n")])]),n._v(" "),t("p",[t("strong",[n._v("注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。")])]),n._v(" "),t("h3",{attrs:{id:"_2-对象的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-对象的解构赋值"}},[n._v("#")]),n._v(" 2.对象的解构赋值")]),n._v(" "),t("p",[n._v("解构不仅可以用于数组，还可以用于对象。")]),n._v(" "),t("pre",[t("code",[n._v('let { foo, bar } = { foo: "aaa", bar: "bbb" };\nfoo // "aaa"\nbar // "bbb"\n')])]),n._v(" "),t("p",[n._v("对象的解构也可以指定默认值\n默认值生效的条件是，对象的属性值严格等于undefined。")]),n._v(" "),t("h3",{attrs:{id:"_3-字符串的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-字符串的解构赋值"}},[n._v("#")]),n._v(" 3.字符串的解构赋值")]),n._v(" "),t("p",[n._v("字符串也可以解构赋值。")]),n._v(" "),t("pre",[t("code",[n._v('const [a, b, c, d, e] = \'hello\';\na // "h"\nb // "e"\nc // "l"\nd // "l"\ne // "o"\n')])]),n._v(" "),t("p",[n._v("类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。")]),n._v(" "),t("pre",[t("code",[n._v("let {length : len} = 'hello';\nlen // 5\n")])]),n._v(" "),t("h3",{attrs:{id:"_4-数值和布尔值的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-数值和布尔值的解构赋值"}},[n._v("#")]),n._v(" 4.数值和布尔值的解构赋值")]),n._v(" "),t("p",[n._v("解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。")]),n._v(" "),t("pre",[t("code",[n._v("let {toString: s} = 123;\ns === Number.prototype.toString // true\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n")])]),n._v(" "),t("p",[n._v("上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。")]),n._v(" "),t("p",[n._v("解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。")]),n._v(" "),t("pre",[t("code",[n._v("let { prop: x } = undefined; // TypeError\nlet { prop: y } = null; // TypeError\n")])]),n._v(" "),t("h3",{attrs:{id:"_5-函数参数的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-函数参数的解构赋值"}},[n._v("#")]),n._v(" 5.函数参数的解构赋值")]),n._v(" "),t("p",[n._v("函数的参数也可以使用解构赋值。")]),n._v(" "),t("pre",[t("code",[n._v("function add([x, y]){\n  return x + y;\n}\nadd([1, 2]); // 3\n")])]),n._v(" "),t("p",[n._v("上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。\n函数参数的解构也可以使用默认值。")]),n._v(" "),t("pre",[t("code",[n._v("function move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n")])]),n._v(" "),t("h3",{attrs:{id:"_6-用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-用途"}},[n._v("#")]),n._v(" 6.用途")]),n._v(" "),t("p",[n._v("变量的解构赋值用途很多。")]),n._v(" "),t("p",[n._v("####（1）交换变量的值\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x];")]),n._v(" "),t("p",[n._v("####（2）从函数返回多个值\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。")]),n._v(" "),t("pre",[t("code",[n._v("// 返回一个数组\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n// 返回一个对象\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n")])]),n._v(" "),t("p",[n._v("####（3）函数参数的定义\n解构赋值可以方便地将一组参数与变量名对应起来。")]),n._v(" "),t("pre",[t("code",[n._v("// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n")])]),n._v(" "),t("h4",{attrs:{id:"_4）提取-json-数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4）提取-json-数据"}},[n._v("#")]),n._v(" (4）提取 JSON 数据")]),n._v(" "),t("pre",[t("code",[n._v('解构赋值对提取 JSON 对象中的数据，尤其有用。\n\nlet jsonData = {\n  id: 42,\n  status: "OK",\n  data: [867, 5309]\n};\nlet { id, status, data: number } = jsonData;\nconsole.log(id, status, number);\n// 42, "OK", [867, 5309]\n')])]),n._v(" "),t("p",[n._v("####（5）函数参数的默认值\njQuery.ajax = function (url, {\nasync = true,\nbeforeSend = function () {},\ncache = true,\ncomplete = function () {},\ncrossDomain = false,\nglobal = true,\n// ... more config\n} = {}) {\n// ... do stuff\n};")]),n._v(" "),t("p",[n._v("###（6）遍历 Map 结构\n任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。")]),n._v(" "),t("pre",[t("code",[n._v("const map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [[,value] of map) {\n  // ...\n}\n")])]),n._v(" "),t("p",[n._v("####（7）输入模块的指定方法\n加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。")]),n._v(" "),t("pre",[t("code",[n._v('const { SourceMapConsumer, SourceNode } = require("source-map");\n')])])])}],!1,null,null,null);e.default=r.exports}}]);