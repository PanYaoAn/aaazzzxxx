(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{173:function(n,t,o){"use strict";o.r(t);var a=o(0),r=Object(a.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,t=n.$createElement,o=n._self._c||t;return o("div",{staticClass:"content"},[o("h2",{attrs:{id:"闭包"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),o("h3",{attrs:{id:"什么是闭包"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[n._v("#")]),n._v(" 什么是闭包")]),n._v(" "),o("pre",[o("code",[n._v(' JS 的函数内部可以使用函数外部的变量\n在函数 和 函数内部能访问到的变量 的总和, 就是一个闭包\nvar local = "变量"\nfunction foo(){\n\tconsole.log(local)\n}\n上面三行代码在一个立即执行函数中。\n\n三行代码中，有一个局部变量 local，有一个函数 foo，foo 里面可以访问到 local 变量。\n')])]),n._v(" "),o("p",[n._v("###闭包嵌套函数\nfunction foo(){\nvar local = 1\nfunction bar(){\nlocal++\nreturn local\n}\nreturn bar\n}\nvar func = foo()\nfunc()\nlocal 变量和 bar 函数就组成了一个闭包（Closure）。")]),n._v(" "),o("pre",[o("code",[n._v("为什么要函数套函数呢？\n是因为需要局部变量 所以把local放在函数里,如果不把local放在函数,local就变成了全局变量 就达不到使用闭包的目的(隐藏变量)\n为什么要 return bar 呢？\n如果不return 就无法使用这个闭包 retuen bar就是只要外部能访问到这个bar函数就行了\n所以 return bar 只是为了 bar 能被使用，也跟闭包无关。\n")])]),n._v(" "),o("p",[n._v("###闭包的作用\n闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。\n假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。")]),n._v(" "),o("pre",[o("code",[n._v("如果不用闭包，你可以直接用一个全局变量：\n\nwindow.lives = 30 // 还有三十条命\n这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？\n\n用局部变量。\n\n但是用局部变量别人又访问不到，怎么办呢？\n\n暴露一个访问器（函数），让别人可以「间接访问」。\n\n!function(){\n\tvar lives = 50 //函数内部变量\n\n\twindow.addlife = function(){\n\t\tlives += 1\n\t}//闭包\n\twindow.lostlife = function(){\n\t\tlives -= 1\n\t}//闭包\n\n\n}\n那么在其他的 JS 文件，就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。")])])])}],!1,null,null,null);t.default=r.exports}}]);