(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{213:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h3",{attrs:{id:"什么是块级作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是块级作用域"}},[t._v("#")]),t._v(" 什么是块级作用域?")]),t._v(" "),n("p",[t._v("定义:")]),t._v(" "),n("pre",[n("code",[t._v(" 是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。\n")])]),t._v(" "),n("p",[t._v("为何需要块级作用域?")]),t._v(" "),n("pre",[n("code",[t._v("在ES6之前，函数只能在全局作用域和函数作用域中声明，不能在块级作用域中声明。没有块级作用域导致很多场景不合理\n1、内存变量可能覆盖外层变量\n2、用来计数的循环变量泄露为全局变量\n")])]),t._v(" "),n("h3",{attrs:{id:"es6中的块级作用域："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6中的块级作用域："}},[t._v("#")]),t._v(" ES6中的块级作用域：")]),t._v(" "),n("pre",[n("code",[t._v("1、允许块级作用域任意嵌套，外层作用域无法读取内层作用域的变量\n2、内层作用域可以定义外层作用域的同名变量\n3、不需要立即执行匿名函数\n")])]),t._v(" "),n("p",[t._v("###es6的变量声明\nES6中新增let 和 const来定义变量\nvar : ES5和ES6中 定义全局变量\nlet : 来定义局部变量 代替var\nconst : 定义常量(定义后不可修改)")]),t._v(" "),n("h3",{attrs:{id:"var、let、const的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#var、let、const的区别"}},[t._v("#")]),t._v(" var、let、const的区别")]),t._v(" "),n("pre",[n("code",[t._v("1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。\n2. let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。\n3.const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。\n")])]),t._v(" "),n("h3",{attrs:{id:"let-和-const-的作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const-的作用"}},[t._v("#")]),t._v(" let 和 const 的作用")]),t._v(" "),n("pre",[n("code",[t._v("1.禁止重复声明\n2.支持块级作用域\n3.支持修改\n相反,用var声明的变量 : 可以重复声明 没有块级作用域.不能限制")])])])}],!1,null,null,null);e.default=a.exports}}]);