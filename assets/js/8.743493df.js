(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{174:function(t,n,e){"use strict";e.r(n);var a=e(0),r=Object(a.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"什么事防抖和节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么事防抖和节流"}},[t._v("#")]),t._v(" 什么事防抖和节流")]),t._v(" "),e("h2",{attrs:{id:"防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖"}},[t._v("#")]),t._v(" 防抖")]),t._v(" "),e("pre",[e("code",[t._v("触发高频事件后 n 秒内事件只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间；\n防止一个事件多次触发,就设置一个定时器,在规定时间函数只会触发一次,如果在规定时间内再次触发,就重新计算时间,\n比如你3秒后触发一个事件,这个事件在3秒后才会触发,你在3秒内再次点击,就会重新等3秒后触发\n\n\nfunction a(fn,delay){\n\tvat timmer = null\n\t//清除上一次延时器\n\treturn funcion(){\n\t\tclearTimeout(timmer)\n\t\t//重新设置一个延时\n\t\ttimmer = setTimeout(()=>{\n\t\t\tfn.call(this)\n\t\t},delay)\n\t}\n}\n")])]),t._v(" "),e("p",[t._v("##节流\n高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。\n思路：\n每次触发事件时都判断当前是否有等待执行的延时函数。\n防止用户多次触发事件,设定在规定时间内事件只能触发一次,时间过来再触发第二次")]),t._v(" "),e("pre",[e("code",[t._v("var cd = false\nif(cd){\n\tconsole.log('请不要频繁触发')\n}else{\n\tfn()\n\tcd = true\n\tvar timmer = setTimeout(()=>{\n\t\tcd = false\n\t},3000)\n}\n")])])])}],!1,null,null,null);n.default=r.exports}}]);