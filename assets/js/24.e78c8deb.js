(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{190:function(e,t,r){"use strict";r.r(t);var a=r(0),s=Object(a.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"vue数据响应式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue数据响应式"}},[e._v("#")]),e._v(" Vue数据响应式")]),e._v(" "),r("p",[e._v("什么是数据驱动\n数据和视图同步，即数据绑定。\n数据驱动是vuejs最大的特点。在vuejs中，所谓的数据驱动就是当数据发生变化的时候，\n用户界面发生相应的变化，开发者不需要手动的去修改dom")]),e._v(" "),r("h3",{attrs:{id:"_1-object-defineproperty-监听修改读取数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-object-defineproperty-监听修改读取数据"}},[e._v("#")]),e._v(" 1.Object.defineProperty 监听修改读取数据")]),e._v(" "),r("p",[e._v("Object.defineProperty(obj, prop, descriptor) 可传入三个值，其作用是该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n第一个值传入要修改的对象\n第二个值传入该对象中要修改的key\n第三个值是一个对象，里面有set 和get两种方法 set为值发生修改是所做的操作 get为读取改值时的操作")]),e._v(" "),r("h3",{attrs:{id:"_1-响应式原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-响应式原理"}},[e._v("#")]),e._v(" 1.响应式原理")]),e._v(" "),r("p",[e._v("在生成vue实例时，为对传入的data进行遍历，使用Object.defineProperty把这些属性转为getter/setter.\n每个vue实例都有一个watcher实例，它会在实例渲染时记录这些属性，并在setter触发时重新渲染。")]),e._v(" "),r("h3",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点:")]),e._v(" "),r("p",[e._v("无法监听数组的所有变动及对象的新增和删除,无法重新渲染数据\n因为只要在 data 中声明的基本数据类型的数据，基本不存在数据不响应问题，所以重点介绍数组\n和对象在vue中的数据响应问题vue可以检测对象属性的修改，但无法监听数组的所有变动及对象的\n新增和删除，只能使用数组变异方法及$set方法。")]),e._v(" "),r("h3",{attrs:{id:"_3-异步更新队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步更新队列"}},[e._v("#")]),e._v(" 3.异步更新队列")]),e._v(" "),r("p",[e._v("vue更新dom时是异步执行的\n数据变化、更新是在主线程中同步执行的；在侦听到数据变化时，watcher将数据变更存储到异步队列中，当本次数据变化，即主线成任务执行完毕，异步队列中的任务才会被执行（已去重）。\n如果你在js中更新数据后立即去操作DOM，这时候DOM还未更新；vue提供了nextTick接口来处理这样的情况，它的参数是一个回调函数，会在本次DOM更新完成后被调用。")]),e._v(" "),r("h3",{attrs:{id:"为什么vue不能监听数组的变化？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么vue不能监听数组的变化？"}},[e._v("#")]),e._v(" 为什么vue不能监听数组的变化？")]),e._v(" "),r("p",[e._v("Object.defindProperty虽然能够实现双向绑定了，但是还是有缺点，只能对对象的属性进行数据劫持，所以会深度遍历整个对象，不管层级有多深，只要数组中嵌套有对象，就能监听到对象的数据变化无法监听到数组的变化，Proxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用Proxy代替definedProperty。")])])}],!1,null,null,null);t.default=s.exports}}]);