(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{172:function(t,n,e){"use strict";e.r(n);var r=e(0),s=Object(r.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"js重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js重载"}},[t._v("#")]),t._v(" JS重载")]),t._v(" "),e("h3",{attrs:{id:"重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[t._v("#")]),t._v(" 重载")]),t._v(" "),e("pre",[e("code",[t._v("方法名相同,形参个数或者类型不一样(JS不存在真正意义上的重载,JS中的重载指的是同一个方法,根据传参不同,实现出不同的效果)\n")])]),t._v(" "),e("h3",{attrs:{id:"重写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重写"}},[t._v("#")]),t._v(" 重写")]),t._v(" "),e("pre",[e("code",[t._v("在类的继承当中,子类可以重写父类的方法\n")])]),t._v(" "),e("h3",{attrs:{id:"什么是面向对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是面向对象"}},[t._v("#")]),t._v(" 什么是面向对象")]),t._v(" "),e("pre",[e("code",[t._v("面向对象是一种编程思想.JS本身就是基于面向对象构建出来的,(例如:JS中有很多内置类,像Promise就是es6中新增的内置类我们可以基于new Promise来创建一个实例,来管理异步编程,我在项目中,Promise也经常用. )VUe页数基于面向对象构建出来的,它们都是类,平时开发都是创建它们的实例操作,我在真实项目中也封装过一些组件插件,也是基于面向对象发开. \n\nJS中面向对象和其他编程语言还是有略微不同,JS中类和实例是基于原型和原型链机制来处理 ,JS中关于类的重载,重写,继承也和其他语言不太一样\n")])]),t._v(" "),e("h3",{attrs:{id:"类的继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的继承"}},[t._v("#")]),t._v(" 类的继承")]),t._v(" "),e("pre",[e("code",[t._v("子类继承父类中的属性和方法(目的是让子类的实例能够调取父类的属性和方法)\n方案1:原型继承\n// 子类.prototype = new 父类\n// 子类.prototype.constructor = 子类 \n特点:\n\t1.不像其他语言中的继承(其他语言的继承一般是拷贝继承,也就是子类继承父类,会把父类中的属性和方法拷贝到一份到子类总,供子类实例调取使用)他是把父类原型放到子类实例的原型链上实例调取这些方法,基于_proto_原型链查找机制完成的\n\t让父类中的属性和方法在子类实例的原型链上\n\t2.子类可以重写父类上的方法(这样会导致父类其他的实例也受到影响)\n\t3.父类中私有或者公有的属性方法,最后都会变为子类中公有的属性和方法\nfunction A(x) {\n        // x s私有属性\n        this.x = x\n}\n    A.prototype.getX = function() {\n        console.log(this.x)\n    }\n\n    function B(y) {\n        this.y = y;\n    }\n    B.prototype = new A(200)\n    B.prototype.constructor = B //保证原型重定向后的完整性\n    B.prototype.getY = function() {\n        console.log(this.y)\n    }\n    let b1 = new B(100);\n    b1.y;\n    b1.getY()\n    b1.getX() //undefind")])])])}],!1,null,null,null);n.default=s.exports}}]);