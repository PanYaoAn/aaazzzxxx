(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{171:function(a,t,r){"use strict";r.r(t);var n=r(0),s=Object(n.a)({},(function(){var a=this.$createElement;this._self._c;return this._m(0)}),[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"js合并两个数组的方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js合并两个数组的方法"}},[a._v("#")]),a._v(" JS合并两个数组的方法")]),a._v(" "),r("pre",[r("code",[a._v("我们在项目过程中，有时候会遇到需要将两个数组合并成为一个的情况。比如：\nvar a = [1,2,3];\nvar b = [4,5,6];\n有两个数组a、b，需求是将两个数组合并成一个。方法如下：\n")])]),a._v(" "),r("h3",{attrs:{id:"contact"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#contact"}},[a._v("#")]),a._v(" contact")]),a._v(" "),r("pre",[r("code",[a._v("js的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。\n\n var a = [1,2,3];\n var b = [4,5,6];\n var c = a.concat(b);//c=[1,2,3,4,5,6];。\n缺点:这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，所以这个方法肯定不是最好的。\n")])]),a._v(" "),r("h3",{attrs:{id:"for循环"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#for循环"}},[a._v("#")]),a._v(" for循环")]),a._v(" "),r("pre",[r("code",[a._v("for(var i in b){\n  a.push(b[i]);\n}\n这样的写法可以解决第一种方案中对内存的浪费，但是会有另一个问题：丑！这么说不是没有道理，如果能只用一行代码就搞定，岂不快哉~\n")])]),a._v(" "),r("h3",{attrs:{id:"apply"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[a._v("#")]),a._v(" apply")]),a._v(" "),r("pre",[r("code",[a._v("函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。所以我们可以利用这点，直接上代码：\na.push.apply(a,b);\n\n调用a.push这个函数实例的apply方法，同时把，b当作参数传入，这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。\n上面的操作就等同于：\na.push(4,5,6);\n")])]),a._v(" "),r("h3",{attrs:{id:"扩展运算符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[a._v("#")]),a._v(" 扩展运算符")]),a._v(" "),r("h4",{attrs:{id:"对象中的扩展运算符-用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象中的扩展运算符-用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中"}},[a._v("#")]),a._v(" 对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中")]),a._v(" "),r("pre",[r("code",[a._v("let bar = { a: 1, b: 2 };\nlet baz = { ...bar }; // { a: 1, b: 2 }\n\n上述方法实际上等价于:\nlet bar = { a: 1, b: 2 };\nlet baz = Object.assign({}, bar); // { a: 1, b: 2 }\n\nvar a = [1,2,3];\nvar b = [4,5,6];\nvar newA = [...a,...b]\n")])])])}],!1,null,null,null);t.default=s.exports}}]);