(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{208:function(e,n,r){"use strict";r.r(n);var o=r(0),t=Object(o.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),r("h3",{attrs:{id:"_1-什么是promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是promise"}},[e._v("#")]),e._v(" 1.什么是promise")]),e._v(" "),r("pre",[r("code",[e._v("1、主要用于异步计算\n2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果\n3、可以在对象之间传递和操作promise，帮助我们处理队列\n\n为了避免界面冻结（任务）\n\n1.1 \n同步：假设你去了一家饭店，找个位置，叫来服务员， 这个时候服务员对你说，对不起我是“同步”服务员，\n我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却\n要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，\n必须按照1234的顺序完成”。\n\n1.2\n异步：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作\n之后，再通过回调或者事件，继续做A剩下的工作。AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。\n\n1.3\nPromise对象代表一个未完成、但预计将来会完成的操作。\n它有以下三种状态：\npending：初始值，不是fulfilled，也不是rejected\nfulfilled：代表操作成功\nrejected：代表操作失败\nPromise有两种状态改变的方式，既可以从pending转变为fulfilled，\n也可以从pending转变为rejected。一旦状态改变，就「凝固」了，会一直保持这个状态，\n不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。\n注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一。\n1.4promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）\n并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据\n代码风格，容易理解，便于维护\n多个异步等待合并便于解决\n")])]),e._v(" "),r("h3",{attrs:{id:"_2-resolve-reject"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-resolve-reject"}},[e._v("#")]),e._v(" 2.resolve,reject")]),e._v(" "),r("pre",[r("code",[e._v("2.1 resolve 和 reject\nresolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； \nreject函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n// resolve == then\n// reject == catch\n\nlet promise = new Promise((resolve,reject) => {\n\tresolve(参数)//进入 then 代码块\n\treject(参数) // 进入catch 代码块\n})\n\npromise.then(response => {\n\tconsoloe.log(response)//参数\n\tconsole.log('成功')\n}).catch(error => {\nconsoloe.log(error)//参数\n\tconsole.log('失败)\n})\n")])]),e._v(" "),r("h3",{attrs:{id:"_3-all-ract"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-all-ract"}},[e._v("#")]),e._v(" 3 .all() , .ract()")]),e._v(" "),r("h4",{attrs:{id:"_3-1-all"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-all"}},[e._v("#")]),e._v(" 3.1 .all()")]),e._v(" "),r("pre",[r("code",[e._v('数组内有promise必须全部返回成功(全部返回resolve)才会执行then回调 \n只有一个是返回(reject)不成功就会执行catch\nfunction fn1(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第1个promise成功");\n      resolve("第1个promise返回成功");\n\t})\n};\nfunction fn2(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第2个promise成功");\n      resolve("第2个promise返回成功");\n\t})\n};\nfunction fn3(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第2个promise成功");\n      resolve("第2个promise返回成功");\n\t})\n};\ninit(){\n\tPromise.all([fn1(),fn2(),fn3()])\n\t.then(response => {\n\t\tconsole.log(\'全部调用成功\')\t\n}).catch(error => {\n\tconsole.log(\'有些失败了\')\n})\n};\n')])]),e._v(" "),r("h4",{attrs:{id:"_3-2-race"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-race"}},[e._v("#")]),e._v(" 3.2 .race()")]),e._v(" "),r("pre",[r("code",[e._v('顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([fn1(), fn2(), fn3()])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。\nfunction fn1(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第1个promise成功");\n      resolve("第1个promise返回成功");\n\t})\n};\nfunction fn2(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第2个promise成功");\n      resolve("第2个promise返回成功");\n\t})\n};\nfunction fn3(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第2个promise成功");\n      resolve("第2个promise返回成功");\n\t})\n};\ninit(){\n    Promise.race([fn1(),fn2(),fn3()])\n    .then(response => {\n        console.log(response)\n        console.log(\'111111\')\n        \n    })\n    .catch(error => {\n        console.log(error)\n\n        console.log(\'22222\')\n\n    })\n\n}\n')])]),e._v(" "),r("h3",{attrs:{id:"链式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链式"}},[e._v("#")]),e._v(" 链式")]),e._v(" "),r("pre",[r("code",[e._v('function fn1(){\n  \tlet promiseDemo = new Promise((resolve,reject) => {\n        resolve(\'success\')\n        reject(\'failed\')\n      })\n\t.then(response => { //第一个\n\t\tconsloe.log(response)\n\t\treturn fn2()\n\t})\n\t.then(response => {\n\t\tconsloe.log(response)\n\t\treturn fn3()\n\t}) \n\t.catch(error => {\n\t\tconsole.log(error)\n\t})\n\n};\nfunction fn2(){ //第二个\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第1个promise成功");\n      resolve("第1个promise返回成功");\n\t})\n}\nfunction fn3(){\n\treturn new Promise((resolve,reject) => {\n\t  console.log("第2个promise成功");\n      resolve("第2个promise返回成功");\n\t})\n}\n')])])])}],!1,null,null,null);n.default=t.exports}}]);