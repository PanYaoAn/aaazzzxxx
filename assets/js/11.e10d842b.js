(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{177:function(o,n,t){"use strict";t.r(n);var e=t(0),r=Object(e.a)({},(function(){var o=this.$createElement;this._self._c;return this._m(0)}),[function(){var o=this,n=o.$createElement,t=o._self._c||n;return t("div",{staticClass:"content"},[t("p",[o._v("#js面向对象\n######简单封装对象")]),o._v(" "),t("pre",[t("code",[o._v("var dog = {\n\tname:'旺财',\n\tcolor:'黄色'\n}\n\nvar dog1 =  {}\ndog1.name = '来福';\ndog1.color = '白色';\n")])]),o._v(" "),t("p",[o._v("#######函数对象\nfunction Dog(name,color){\nreturn{\nname:name,\ncolor:color\n}")]),o._v(" "),t("pre",[t("code",[o._v("}\nvar dog3 = Dog('来福','黄色');\nvar dog3 = Dog('旺财','黑色');\n")])]),o._v(" "),t("p",[o._v("#######封装对象\nfunction GetDog(name,color){\nthis.name = name;\nthis.color = color;")]),o._v(" "),t("pre",[t("code",[o._v("}\nvar dog5 = new GetDog('嘤嘤嘤','粉色');\n所谓\"构造函数\"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。\n")])]),o._v(" "),t("h5",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[o._v("#")])]),o._v(" "),t("pre",[t("code",[o._v("Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象\t的所有属性和方法，都会被构造函数的实例继承。\n这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n\nfunction GetDog2(name,color){\n\tthis.name = name;\n\tthis.color = color;\n}\nGetDog2.prototype.type = '犬科动物';\nGetDog2.prototype.eat = function(){alert('爱吃骨头')};\ndog7 = new GetDog2('大大','黑白色')\n")])]),o._v(" "),t("h2",{attrs:{id:"-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[o._v("#")])]),o._v(" "),t("pre",[t("code",[o._v("isPrototypeOf():这个方法用来判断，某个proptotype对象和某个实例之间的关系\n\nhasOwnproperty():用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。\n\nin:运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。也可以用来遍历对象属性。\n")])]),o._v(" "),t("p",[o._v("###对象的继承\n1.使用call 或者 apply 来进行继承\ncall()定义：调用一个对象的一个方法，以另一个对象替换当前对象。\narguments是一个特殊对象，一般用于代替未名的实参，使用方法类似对象arguments[i]。\n也可使用arguments.lenght来获取参数的个数")]),o._v(" "),t("pre",[t("code",[o._v('2.使用prototype属性来完成\nDog.prototype = new Animal();//将Dog的prototype对象指向一个Anima的实例\n\n任何一个prototype对象都有一个constructor属性，指向它的构造函数。\n任何一个prototype对象都有一个constructor属性，指向它的构造函数。因此，在运行"Dog.prototype = new Animal();"这一行之后，dog2.constructor也指向Animal！\n因此我们必须手动纠正，将Dog.prototype对象的constructor值改为Dog\n因此我们必须手动纠正,将Dog.prototype对象的constructor值改为Dog\n\nDog.prototype.constructor = Dog;\n')])])])}],!1,null,null,null);n.default=r.exports}}]);