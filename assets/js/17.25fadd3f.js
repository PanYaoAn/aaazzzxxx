(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{183:function(n,e,r){"use strict";r.r(e);var a=r(0),o=Object(a.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"深拷贝和浅拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[n._v("#")]),n._v(" 深拷贝和浅拷贝")]),n._v(" "),r("h3",{attrs:{id:"实现浅拷贝的方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现浅拷贝的方法"}},[n._v("#")]),n._v(" 实现浅拷贝的方法")]),n._v(" "),r("p",[n._v("如果是基本数据类型，名字和值都会储存在栈内存中")]),n._v(" "),r("pre",[r("code",[n._v("var a = 1;\nb = a; // 栈内存会开辟一个新的内存空间，此时b和a都是相互独立的\nb = 2;\nconsole.log(a); // 1\n")])]),n._v(" "),r("p",[n._v("(1) for循环 值循环第一层")]),n._v(" "),r("pre",[r("code",[n._v("let a = {\n    name: '我是a'\n}\nlet b = copyObj(a)\n\n function copyObj(o) {\n    let newObj = {};\n    for (let key in o) {\n        newObj[key] = o[key];\n    }\n    return newObj\n}\n")])]),n._v(" "),r("p",[n._v("(2)Object.assign方法")]),n._v(" "),r("pre",[r("code",[n._v("var obj = {\n    a: 1,\n    b: 2\n}\nvar obj1 = Object.assign(obj);\nobj1.a = 3;\nconsole.log(obj.a) // 3\n")])]),n._v(" "),r("h3",{attrs:{id:"实现深拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现深拷贝"}},[n._v("#")]),n._v(" 实现深拷贝")]),n._v(" "),r("p",[n._v("（1） 通过JSON对象来实现深拷贝")]),n._v(" "),r("pre",[r("code",[n._v("function deepClone2(obj) {\n  var _obj = JSON.stringify(obj),\n    objClone = JSON.parse(_obj);\n  return objClone;\n}\n")])]),n._v(" "),r("p",[n._v("缺点： 无法实现对对象中方法的深拷贝，会显示为undefined")]),n._v(" "),r("p",[n._v("（2）通过jQuery的extend方法实现深拷贝")]),n._v(" "),r("pre",[r("code",[n._v("var array = [1,2,3,4];\nvar newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝\n")])]),n._v(" "),r("p",[n._v("（3）如果对象的value是基本类型的话，也可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象")]),n._v(" "),r("pre",[r("code",[n._v("var obj = {\n    a: 1,\n    b: 2\n}\nvar obj1 = Object.assign({}, obj); // obj赋值给一个空{}\nobj1.a = 3;\nconsole.log(obj.a)；// 1\n")])]),n._v(" "),r("p",[n._v("（4）直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。")]),n._v(" "),r("pre",[r("code",[n._v("function deepClone(initalObj, finalObj) {    \n  var obj = finalObj || {};    \n  for (var i in initalObj) {        \n    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况\n    if(prop === obj) {            \n      continue;\n    }        \n    if (typeof prop === 'object') {\n      obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);\n    } else {\n      obj[i] = prop;\n    }\n  }    \n  return obj;\n}\n")])]),n._v(" "),r("p",[n._v("(5) 使用扩展运算符实现深拷贝")]),n._v(" "),r("pre",[r("code",[n._v('// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的\n// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝\nvar car = {brand: "BMW", price: "380000", length: "5米"}\nvar car1 = { ...car, price: "500000" }\nconsole.log(car1); // { brand: "BMW", price: "500000", length: "5米" }\nconsole.log(car); // { brand: "BMW", price: "380000", length: "5米" }')])])])}],!1,null,null,null);e.default=o.exports}}]);